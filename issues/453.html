<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 453</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 111d.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2023-05-12</P>
<HR>
<A NAME="453"></A><H4>453.
  
References may only bind to &#8220;valid&#8221; objects
</H4>
<B>Section: </B>9.3.4.3&#160; [<A href="https://wg21.link/dcl.ref">dcl.ref</A>]
 &#160;&#160;&#160;

 <B>Status: </B>drafting
 &#160;&#160;&#160;

 <B>Submitter: </B>Gennaro Prota
 &#160;&#160;&#160;

 <B>Date: </B>18 Jan 2004<BR>


<P>9.3.4.3 [<A href="https://wg21.link/dcl.ref#4">dcl.ref</A>] paragraph 4 says:</P>
<BLOCKQUOTE>
  A reference shall be initialized to refer to a valid object or
  function. [Note: in particular, a null reference cannot exist
  in a well-defined program, because the only way to create such
  a reference would be to bind it to the "object" obtained by
  dereferencing a null pointer, which causes undefined behavior
  ...]
</BLOCKQUOTE>
<P>What is a "valid" object? In particular the expression "valid object"
seems to exclude uninitialized objects, but the response to Core Issue
363 clearly says that's not the intent. This is an example
(overloading construction on constness of *this) by John Potter, which
I think is supposed to be legal C++ though it binds references to
objects that are not initialized yet:</P>
<PRE>
 struct Fun {
    int x, y;
    Fun (int x, Fun const&amp;) : x(x), y(42) { }
    Fun (int x, Fun&amp;) : x(x), y(0) { }
  };
  int main () {
    const Fun f1 (13, f1);
    Fun f2 (13, f2);
    cout &lt;&lt; f1.y &lt;&lt; " " &lt;&lt; f2.y &lt;&lt; "\n";
  }
</PRE>

<P>Suggested resolution: Changing the final part of
9.3.4.3 [<A href="https://wg21.link/dcl.ref#4">dcl.ref</A>] paragraph 4 to:</P>
<BLOCKQUOTE>
  A reference shall be initialized to refer to an object or function.
  From its point of declaration on (see 6.4.2 [<A href="https://wg21.link/basic.scope.pdecl">basic.scope.pdecl</A>])
  its name is an lvalue
  which refers to that object or function. The reference may be
  initialized to refer to an uninitialized object but, in that case,
  it is usable in limited ways (6.7.3 [<A href="https://wg21.link/basic.life">basic.life</A>], paragraph 6)
  [Note: On the other hand, a declaration like this:
<PRE>
    int &amp; ref = *(int*)0;
</PRE>
  is ill-formed because ref will not refer to any object or function
  ]
</BLOCKQUOTE>

<P>I also think a "No diagnostic is required." would better be added
(what about something like int&amp; r = r; ?)</P>

<P><B>Proposed Resolution (October, 2004):</B></P>

<P>(Note: the following wording depends on the proposed
resolution for <A HREF="232.html">issue 232</A>.)</P>

<P>Change 9.3.4.3 [<A href="https://wg21.link/dcl.ref#4">dcl.ref</A>] paragraph 4 as follows:</P>
<BLOCKQUOTE>

<P>
<DEL>A reference shall be initialized to refer to a valid object
or function.</DEL> <INS>If an lvalue to which a reference is directly
bound designates neither an existing object or function of an
appropriate type (9.4.4 [<A href="https://wg21.link/dcl.init.ref">dcl.init.ref</A>]), nor a region of
memory of suitable size and alignment to contain an object of the
reference's type (6.7.2 [<A href="https://wg21.link/intro.object">intro.object</A>], 6.7.3 [<A href="https://wg21.link/basic.life">basic.life</A>], 6.8 [<A href="https://wg21.link/basic.types">basic.types</A>]), the behavior is
undefined.</INS> [<I>Note:</I> in particular, a null reference cannot
exist in a well-defined program, because the only way to create
such a reference would be to bind it to the
<DEL>&#8220;object&#8221;</DEL> <INS>empty lvalue</INS> obtained by
dereferencing a null pointer, which <DEL>causes undefined behavior.
As</DEL> <INS>does not designate an object or function.  Also, as
</INS> described in 11.4.10 [<A href="https://wg21.link/class.bit">class.bit</A>],
a reference cannot be bound directly to a
bit-field. ]</P>

<P><INS>The name of a reference shall not be used in its own
initializer.  Any other use of a reference before it is
initialized results in undefined behavior.  [<I>Example:</I>
</INS></P>

<INS>
<PRE>
  int&amp; f(int&amp;);
  int&amp; g();

  extern int&amp; ir3;
  int* ip = 0;

  int&amp; ir1 = *ip;     // <I>undefined behavior: null pointer</I>
  int&amp; ir2 = f(ir3);  // <I>undefined behavior: </I>ir3<I> not yet initialized</I>
  int&amp; ir3 = g();
  int&amp; ir4 = f(ir4);  // <I>ill-formed: </I>ir4<I> used in its own initializer</I>
</PRE>
&#8212;<I>end example</I>]
</INS>
</BLOCKQUOTE>

<P>
<B>Rationale: </B> The proposed wording goes beyond the specific
concerns of the issue.  It was noted that, while the current
wording makes cases like <TT>int&amp; r = r;</TT> ill-formed (because
<TT>r</TT> in the initializer does not "refer to a valid object"), an
inappropriate initialization can only be detected, if at all, at
runtime and thus "undefined behavior" is a more appropriate treatment.
Nevertheless, it was deemed desirable to continue to require a
diagnostic for obvious compile-time cases.
</P>

<P>It was also noted that the current Standard does not say anything
about using a reference before it is initialized.  It seemed
reasonable to address both of these concerns in the same wording
proposed to resolve this issue.
</P>

<P><B>Notes from the April, 2005 meeting:</B></P>

<P>The CWG decided that whether to require an implementation to
diagnose initialization of a reference to itself should be handled as
a separate issue (<A HREF="504.html">504</A>) and also suggested referring
to &#8220;storage&#8221; instead of &#8220;memory&#8221; (because
6.7.2 [<A href="https://wg21.link/intro.object">intro.object</A>] defines an object as a &#8220;region of
storage&#8221;).</P>

<P><B>Proposed Resolution (April, 2005):</B></P>

<P>(Note: the following wording depends on the proposed
resolution for <A HREF="232.html">issue 232</A>.)</P>

<P>Change 9.3.4.3 [<A href="https://wg21.link/dcl.ref#4">dcl.ref</A>] paragraph 4 as follows:</P>
<BLOCKQUOTE>

<P>
<DEL>A reference shall be initialized to refer to a valid object
or function.</DEL> <INS>If an lvalue to which a reference is directly
bound designates neither an existing object or function of an
appropriate type (9.4.4 [<A href="https://wg21.link/dcl.init.ref">dcl.init.ref</A>]), nor a region of
storage of suitable size and alignment to contain an object of the
reference's type (6.7.2 [<A href="https://wg21.link/intro.object">intro.object</A>], 6.7.3 [<A href="https://wg21.link/basic.life">basic.life</A>], 6.8 [<A href="https://wg21.link/basic.types">basic.types</A>]), the behavior is
undefined.</INS> [<I>Note:</I> in particular, a null reference cannot
exist in a well-defined program, because the only way to create
such a reference would be to bind it to the
<DEL>&#8220;object&#8221;</DEL> <INS>empty lvalue</INS> obtained by
dereferencing a null pointer, which <DEL>causes undefined behavior.
As</DEL> <INS>does not designate an object or function.  Also, as
</INS> described in 11.4.10 [<A href="https://wg21.link/class.bit">class.bit</A>],
a reference cannot be bound directly to a
bit-field. ]</P>

<P><INS>Any use of a reference before it is initialized results in
undefined behavior.  [<I>Example:</I>
</INS></P>

<INS>
<PRE>
  int&amp; f(int&amp;);
  int&amp; g();

  extern int&amp; ir3;
  int* ip = 0;

  int&amp; ir1 = *ip;     // <SPAN CLASS="cmnt">undefined behavior: null pointer</SPAN>
  int&amp; ir2 = f(ir3);  // <SPAN CLASS="cmnt">undefined behavior: </SPAN>ir3<SPAN CLASS="cmnt"> not yet initialized</SPAN>
  int&amp; ir3 = g();
  int&amp; ir4 = f(ir4);  // <SPAN CLASS="cmnt">undefined behavior: </SPAN>ir4<SPAN CLASS="cmnt"> used in its own initializer</SPAN>
</PRE>
&#8212;<I>end example</I>]
</INS>
</BLOCKQUOTE>

<P><B>Note (February, 2006):</B></P>

<P>The word &#8220;use&#8221; in the last
paragraph of the proposed resolution was intended to refer to the
description in 6.3 [<A href="https://wg21.link/basic.def.odr#2">basic.def.odr</A>] paragraph 2.  However, that
section does not define what it means for a reference to be
&#8220;used,&#8221; dealing only with objects and functions.  Additional
drafting is required to extend 6.3 [<A href="https://wg21.link/basic.def.odr#2">basic.def.odr</A>] paragraph 2
to apply to references.  </P>

<P><B>Additional note (May, 2008):</B></P>

<P>The proposed resolution for <A HREF="570.html">issue 570</A>
adds wording to define &#8220;use&#8221; for references.</P>

<P><B>Note, January, 2012:</B></P>

<P>The resolution should also probably deal with the fact that
the &#8220;one-past-the-end&#8221; address of an array does not
designate a valid object (even if such a pointer might
&#8220;point to&#8221; an object of the correct type, per
6.8.4 [<A href="https://wg21.link/basic.compound">basic.compound</A>]) and thus is not suuitable for the
lvalue-to-rvalue conversion.  </P>

<BR><BR>
</BODY>
</HTML>
