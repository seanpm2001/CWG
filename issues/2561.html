<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 2561</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 111d.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2023-07-16</P>
<HR>
<A NAME="2561"></A><H4>2561.
  
Conversion to function pointer for lambda with explicit object parameter
</H4>
<B>Section: </B>7.5.5.2&#160; [<A href="https://wg21.link/expr.prim.lambda.closure">expr.prim.lambda.closure</A>]
 &#160;&#160;&#160;

 <B>Status: </B>review
 &#160;&#160;&#160;

 <B>Submitter: </B>Barry Revzin
 &#160;&#160;&#160;

 <B>Date: </B>2022-02-14<BR>




<P>P0847R7 (Deducing this) (approved October, 2021) added
explicit-object member functions. Consider:</P>

<PRE>
  struct C {
    C(auto) { }
  };

  void foo() {
    auto l = [](this C) { return 1; };
    void (*fp)(C) = l;
    fp(1); //<SPAN CLASS="cmnt"> same effect as </SPAN>decltype(l){}()<SPAN CLASS="cmnt"> or </SPAN>decltype(l){}(1)<SPAN CLASS="cmnt"> ?</SPAN>
  }
</PRE>

<P>Subclause 7.5.5.2 [<A href="https://wg21.link/expr.prim.lambda.closure#8">expr.prim.lambda.closure</A>] paragraph 8 does not address
explicit object member functions:</P>

<BLOCKQUOTE>

The closure type for a non-generic <I>lambda-expression</I> with
no <I>lambda-capture</I> whose constraints (if any) are satisfied has
a conversion function to pointer to function with C++ language linkage
(9.11 [<A href="https://wg21.link/dcl.link">dcl.link</A>]) having the same parameter and return types
as the closure type's function call operator. The conversion is to
&#8220;pointer to noexcept function&#8221; if the function call
operator has a non-throwing exception specification. The value
returned by this conversion function is the address of a function F
that, when invoked, has the same effect as invoking the closure type's
function call operator on a default-constructed instance of the
closure type. F is a constexpr function if...

</BLOCKQUOTE>

<P><U>Suggested resolution:</U></P>

<OL>

<LI>
<P>Change in 7.5.5.2 [<A href="https://wg21.link/expr.prim.lambda.closure#8">expr.prim.lambda.closure</A>] paragraph 8 as follows:</P>

<BLOCKQUOTE>

... The value returned by this conversion function is

<UL>

<LI><INS>for a <I>lambda-expression</I>
whose <I>parameter-declaration-clause</I> has an explicit object
parameter, the address of the function call operator
(7.6.2.2 [<A href="https://wg21.link/expr.unary.op">expr.unary.op</A>];</INS></LI>

<LI>
<INS>otherwise,</INS> the address of a
function F that, when invoked, has the same effect as invoking the
closure type's function call operator on a default-constructed
instance of the closure type.</LI>

</UL>

F is a constexpr function if... is an immediate function.

<P><INS>[ <I>Example</I>:</INS></P>

<PRE>
  struct C {
    C(auto) { }
  };

  void foo() {
    auto a = [](C) { return 0; };
    int (*fp)(C) = a;   // OK
    fp(1);              //<SPAN CLASS="cmnt"> same effect as </SPAN>decltype(a){}(1)
    auto b = [](this C) { return 1; };
    fp = b;             // OK
    fp(1);              //<SPAN CLASS="cmnt"> same effect as </SPAN>(&amp;decltype(b)::operator())(1)
  }
</PRE>

<P><INS>-- <I>end example</I> ]</INS></P>

</BLOCKQUOTE>
</LI>

<LI>
<P>Change in 7.5.5.2 [<A href="https://wg21.link/expr.prim.lambda.closure#11">expr.prim.lambda.closure</A>] paragraph 11 as follows:</P>

<BLOCKQUOTE>

The value returned by any given specialization of this conversion
function template is

<UL>
<LI>
<INS>for a <I>lambda-expression</I>
whose <I>parameter-declaration-clause</I> has an explicit object
parameter, the address of the corresponding function call operator
template specialization (7.6.2.2 [<A href="https://wg21.link/expr.unary.op">expr.unary.op</A>]);</INS>
</LI>

<LI>
<INS>otherwise,</INS> the address of a function F that, when invoked,
has the same effect as invoking the generic lambda's corresponding
function call operator template specialization on a
default-constructed instance of the closure type.
</LI>
</UL>

F is a constexpr function if...

</BLOCKQUOTE>

</LI>

</OL>

<BR><BR>
</BODY>
</HTML>
