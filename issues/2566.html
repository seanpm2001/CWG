<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>
    CWG Issue 2566</TITLE>
<STYLE TYPE="text/css">
  INS { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  .INS { text-decoration:none; background-color:#D0FFD0 }
  DEL { text-decoration:line-through; background-color:#FFA0A0 }
  SPAN.cmnt { font-family:Times; font-style:italic }
</STYLE>
</HEAD>
<BODY>
<P><EM>This is an unofficial snapshot of the ISO/IEC JTC1 SC22 WG21
  Core Issues List revision 111d.
  See http://www.open-std.org/jtc1/sc22/wg21/ for the official
  list.</EM></P>
<P>2023-05-12</P>
<HR>
<A NAME="2566"></A><H4>2566.
  
Matching deallocation for uncaught exception
</H4>
<B>Section: </B>7.6.2.8&#160; [<A href="https://wg21.link/expr.new">expr.new</A>]
 &#160;&#160;&#160;

 <B>Status: </B>open
 &#160;&#160;&#160;

 <B>Submitter: </B>Jim X
 &#160;&#160;&#160;

 <B>Date: </B>2022-04-13<BR>


<P>Initialization of an object may terminate via an exception, in
which case any dynamically-allocated memory is freed, per
7.6.2.8 [<A href="https://wg21.link/expr.new#26">expr.new</A>] paragraph 26:</P>

<BLOCKQUOTE>

If any part of the object initialization described above [ Footnote:
... ] terminates by throwing an exception and a suitable deallocation
function can be found, the deallocation function is called to free the
memory in which the object was being constructed, after which the
exception continues to propagate in the context of
the <I>new-expression</I>.  If no unambiguous matching deallocation
function can be found, propagating the exception does not cause the
object's memory to be freed.

</BLOCKQUOTE>

<P>However, implementations do not consistently support this provision
in case the exception remains uncaught:</P>

<PRE>
  #include &lt;iostream&gt;
  struct C {
    void* operator new(std::size_t n) {
      std::cout &lt;&lt; "malloc\n";
      return malloc(n);
    }
    void operator delete(void* ptr) {
      std::cout &lt;&lt; "free\n";
      free(ptr);
    }
    C() {
      throw 0;
    }
  };
  int main() {
    auto ptr = new C;
  }
</PRE>

<P>Both clang and GCC do not free the memory in this example; they do
so if the exception is caught in <TT>main</TT>.</P>

<P>Maybe a similar provision as used for stack unwinding in
14.4 [<A href="https://wg21.link/except.handle#9">except.handle</A>] paragraph 9 is desirable:</P>

<BLOCKQUOTE>

If no matching handler is found, the function <TT>std::terminate</TT> is
invoked; whether or not the stack is unwound before this invocation of
<TT>std::terminate</TT> is implementation-defined
(14.6.2 [<A href="https://wg21.link/except.terminate">except.terminate</A>]).

</BLOCKQUOTE>

<P><U>Suggested resolution:</U></P>

<P>Integrate freeing dynamically-allocated memory with stack unwinding
(14.3 [<A href="https://wg21.link/except.ctor">except.ctor</A>]), since this is what implementations
actually do.</P>

<BR><BR>
</BODY>
</HTML>
